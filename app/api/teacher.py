# app/api/teacher.py
from fastapi import APIRouter, HTTPException, UploadFile, File, HTTPException
from datetime import datetime, timedelta
from app.db.database import otps, attendance, approved_teachers, approved_students
from app.core.config import SUBJECTS
from app.utils.otp_utils import generate_otp
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
from io import StringIO
import csv
import pytz
import base64
from app.db.database import notifications
from fastapi import Form
from bson import ObjectId


class GenerateOtpRequest(BaseModel):
    employee_id: str
    course: str 
    branch: str
    semester: str
    subject: str
    duration_minutes: int
    lat: float
    lng: float

class NotificationRequest(BaseModel):
    employee_id: str
    message: str
    branch: str
    section: str
    semester: str
    expiry_time: datetime


router = APIRouter()

# Timezone definitions
IST = pytz.timezone('Asia/Kolkata')

@router.get("/teacher/subjects/{branch}/{semester}")
def get_subjects(branch: str, semester: str):
    branch = branch.upper()
    semester = semester.title()
    if branch not in SUBJECTS:
        raise HTTPException(status_code=404, detail="Branch not found")
    if semester not in SUBJECTS[branch]:
        raise HTTPException(status_code=404, detail="Semester not found in this branch")
    return SUBJECTS[branch][semester]

@router.post("/teacher/generate-otp")
def generate_otp_route(data: GenerateOtpRequest):
    # print("DATA RECEIVED:", data.dict())
    course = data.course.upper()
    branch = data.branch.upper()
    semester = data.semester

    if (
        course not in SUBJECTS or
        branch not in SUBJECTS[course] or
        semester not in SUBJECTS[course][branch] or
        data.subject not in SUBJECTS[course][branch][semester]
    ):
        raise HTTPException(status_code=400, detail="Invalid subject for given course/branch/semester")


    teacher = approved_teachers.find_one({"employee_id": data.employee_id.upper()})
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")

    otp = generate_otp()

    # Store UTC in DB
    now_utc = datetime.utcnow().replace(tzinfo=pytz.utc)
    end_time_utc = now_utc + timedelta(minutes=data.duration_minutes)

    otps.insert_one({
    "otp": otp,
    "teacher_id": data.employee_id.upper(),
    "course": data.course,
    "branch": data.branch,
    "semester": data.semester,
    "subject": data.subject,
    "start_time": now_utc,
    "end_time": end_time_utc,
    "location": {"lat": data.lat, "lng": data.lng}
})


    # Convert to IST for response
    end_time_ist = end_time_utc.astimezone(IST)
    return {
        "otp": otp,
        "course": course,
        "subject": data.subject,
        "branch": data.branch,
        "semester": data.semester,
        "valid_till": end_time_ist.strftime("%Y-%m-%d %H:%M:%S"),
    }

@router.get("/teacher/view-attendance/{employee_id}")
def view_attendance(employee_id: str):
    teacher = approved_teachers.find_one({"employee_id": employee_id.upper()})
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")

    # Fetch all OTPs generated by this teacher
    otps_list = list(otps.find({"teacher_id": employee_id.upper()}))
    otp_codes = [o["otp"] for o in otps_list]

    # Find attendance records matching these OTPs
    records = list(attendance.find({"otp": {"$in": otp_codes}}))

    # Convert marked_at to IST for display
    result = []
    for r in records:
        marked_at_utc = r.get("marked_at")
        if marked_at_utc and marked_at_utc.tzinfo is None:
            marked_at_utc = marked_at_utc.replace(tzinfo=pytz.utc)
        marked_at_ist = marked_at_utc.astimezone(IST).strftime("%Y-%m-%d %H:%M:%S") if marked_at_utc else None

        result.append({
            "student_name": r.get("student_name"),
            "roll_no": r.get("roll_no"),
            "subject": r.get("subject"),
            "marked_at": marked_at_ist,
            "otp": r.get("otp") 
        })

    return result

@router.get("/teacher/export-attendance/{employee_id}")
def export_attendance(employee_id: str):
    teacher = approved_teachers.find_one({"employee_id": employee_id.upper()})
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")

    # Find OTPs generated by this teacher
    otps_list = list(otps.find({"teacher_id": employee_id.upper()}))
    otp_codes = [otp["otp"] for otp in otps_list]

    # Find attendance records matching these OTPs
    records = list(attendance.find({"otp": {"$in": otp_codes}}))

    # Prepare CSV in memory
    output = StringIO()
    writer = csv.writer(output)
    writer.writerow(["Student Name", "Roll Number", "Subject", "Date/Time (IST)"])

    for record in records:
        student = approved_students.find_one({"roll_no": record["roll_no"]})
        name = student["full_name"] if student else "Unknown"
        roll_no = record["roll_no"]
        subject = record["subject"]

        marked_at_utc = record.get("marked_at")
        if marked_at_utc and marked_at_utc.tzinfo is None:
            marked_at_utc = marked_at_utc.replace(tzinfo=pytz.utc)
        dt_ist = marked_at_utc.astimezone(IST).strftime("%Y-%m-%d %H:%M:%S") if marked_at_utc else "N/A"

        writer.writerow([name, roll_no, subject, dt_ist])

    output.seek(0)

    filename = f"attendance_{employee_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
    return StreamingResponse(
        output,
        media_type="text/csv",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )

@router.get("/teacher/profile/{employee_id}")
def get_teacher_profile(employee_id: str):
    employee_id = employee_id.upper()
    teacher = approved_teachers.find_one({"employee_id": employee_id})
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher  not found")
    
    # return only required fields (never return sensitive info)
    return {
        "full_name": teacher.get("full_name"),
        "email": teacher.get("email"),
        "phone": teacher.get("phone"),
        "dob": teacher.get("dob"),
        "gender": teacher.get("gender"),
        "address": teacher.get("address"),
        "employee_id": teacher.get("employee_id"),
        "subject": teacher.get("subject"),
        "photo": teacher.get("photo")
    }

@router.get("/teacher/todays-otps/{employee_id}")
def get_todays_otps(employee_id: str):
    now_ist = datetime.now(IST)
    start_of_day_ist = now_ist.replace(hour=0, minute=0, second=0, microsecond=0)
    start_of_day_utc = start_of_day_ist.astimezone(pytz.utc)

    otps_today = list(otps.find({
        "teacher_id": employee_id.upper(),
        "start_time": {"$gte": start_of_day_utc}
    }).sort("start_time", -1))

    result = []
    for o in otps_today:
        start_time_utc = o["start_time"]
        if start_time_utc.tzinfo is None:
            start_time_utc = start_time_utc.replace(tzinfo=pytz.utc)
        start_time_ist = start_time_utc.astimezone(IST).strftime("%Y-%m-%d %H:%M:%S")

        result.append({
            "otp": o["otp"],
            "subject": o["subject"],
            "start_time": start_time_ist,
            "end_time": o["end_time"].astimezone(IST).strftime("%Y-%m-%d %H:%M:%S")
        })

    return result

@router.get("/teacher/subjects/{course}/{branch}/{semester}")
def get_subjects(course: str, branch: str, semester: str):
    course = course.upper()
    branch = branch.upper()
    semester = semester

    if course not in SUBJECTS:
        raise HTTPException(status_code=404, detail="Course not found")
    if branch not in SUBJECTS[course]:
        raise HTTPException(status_code=404, detail="Branch not found in this course")
    if semester not in SUBJECTS[course][branch]:
        raise HTTPException(status_code=404, detail="Semester not found in this branch")
    
    return SUBJECTS[course][branch][semester]



@router.post("/teacher/profile/upload-photo/{employee_id}")
async def upload_teacher_photo(employee_id: str, file: UploadFile = File(...)):
    employee_id = employee_id.upper()
    teacher = approved_teachers.find_one({"employee_id": employee_id})
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")
    

    # Convert image file to base64 string
    content = await file.read()
    encoded_str = base64.b64encode(content).decode("utf-8")
    
    # Update teacher profile
    approved_teachers.update_one(
        {"employee_id": employee_id},
        {"$set": {"photo": encoded_str}}
    )

    return {"message": "Photo uploaded successfully"}



@router.post("/teacher/send-notification")
async def send_notification(
    employee_id: str = Form(...),
    message: str = Form(...),
    branch: str = Form(...),
    section: str = Form(...),
    semester: str = Form(...),
    expiry_time: str = Form(...),  # ISO format expected
    file: UploadFile = File(None)
):
    teacher = approved_teachers.find_one({"employee_id": employee_id.upper()})
    if not teacher:
        raise HTTPException(status_code=404, detail="Teacher not found")

    file_url = None
    if file:
        content = await file.read()
        filename = f"{employee_id}_{datetime.utcnow().timestamp()}_{file.filename}"
        filepath = f"uploads/notifications/{filename}"
        with open(filepath, "wb") as f:
            f.write(content)
        file_url = f"/files/notifications/{filename}"  # Serve via StaticFiles
    
    notifications.insert_one({
        "sender_id": employee_id.upper(),
        "message": message,
        "file_url": file_url,
        "target_branch": branch.upper(),
        "target_section": section.upper(),
        "target_semester": semester,
        "timestamp": datetime.utcnow(),
        "expiry_time": datetime.fromisoformat(expiry_time)
    })

    return {"message": "Notification sent successfully"}


@router.get("/notifications/{employee_id}")
async def get_teacher_notifications(employee_id: str):
    cursor = notifications.find({"sender_id": employee_id}).sort("timestamp", -1)
    result = []
    async for doc in cursor:
        doc["_id"] = str(doc["_id"])
        if "file_path" in doc:
            doc["file_url"] = f"/files/notifications/{doc['file_path']}"
        result.append(doc)
    return result




@router.delete("/teacher/notifications/{notification_id}")
async def delete_notification(notification_id: str, employee_id: str = Form(...)):
    result = notifications.delete_one({
        "_id": ObjectId(notification_id),
        "sender_id": employee_id.upper()
    })

    if result.deleted_count == 1:
        return {"message": "Notification deleted successfully"}
    else:
        raise HTTPException(status_code=404, detail="Notification not found or unauthorized")
